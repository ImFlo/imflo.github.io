I"ì&<h2 id="introduction">Introduction</h2>

<p>Lâ€™attribut ping de lâ€™Ã©lÃ©ment ancre de la spÃ©cification HTML permet selon la MDN :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Contient une liste d'URL sÃ©parÃ©es par des espaces vers lesquelles sont envoyÃ©es des requÃªtes POST avec le corps PING lorsque l'utilisateur suit le lien. Cet attribut est gÃ©nÃ©ralement utilisÃ© pour tracer un utilisateur.
</code></pre></div></div>

<p>De ce fait, si je crÃ©e une page avec le code suivant, une requÃ¨te POST sera envoyÃ© Ã  <code class="language-plaintext highlighter-rouge">example.com</code>.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">src=</span><span class="s">"/patate"</span> <span class="na">ping=</span><span class="s">"https://example.com"</span><span class="nt">&gt;</span>click me !<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div>

<p><img src="/assets/img/csrf_01.png" alt="" /></p>

<p>Cela peut avoir des utilitÃ©s dans le sens oÃ¹ cet attribut permet de â€œtraquerâ€ les utilisateurs, cependant si lâ€™utilisateur possÃ©de des cookies sur ce site, les cookies sont envoyÃ©s avec la requÃªte, ce qui signifie que si lâ€™utilisateur est authentifiÃ©, celui-ci effectue un POST sur un endpoint qui est dÃ©cidÃ© par lâ€™attaquant.</p>

<h2 id="les-attaques-csrf">les attaques CSRF</h2>

<p>Une attaque de type Cross-Site Request Forgery (ou injection de requÃªte(s) illÃ©gitime(s) par rebond) est une attaque consitant Ã  faire effectuer par un autre utilisateur une requÃ¨te vers une page menant Ã  de lâ€™extraction dâ€™information oÃ¹ a lui faire effectuer une action sans son consentement.</p>

<p>Cela peut avoir un impact plus ou moins Ã©lÃ©vÃ© selon lâ€™action quâ€™il est possible dâ€™effectuer.</p>

<p>GÃ©nÃ©ralement, ce type dâ€™attaque se fait lorsquâ€™une xss (stockÃ©e ou reflÃ©chie) est trouvÃ© sur le site et ainsi lâ€™attaquant peut forger des requÃ¨tes vers dâ€™autres pages du site sans casser le Same Origin Policy, et comme il sâ€™agit du mÃªme site, les cookies de lâ€™utilisateur seront envoyÃ©s.</p>

<p>Une autre technique utilisÃ©e lorsquâ€™aucune xss nâ€™est trouvÃ©, lâ€™idÃ©e est dâ€™attaquer les endpoints â€œGETâ€ disponible via lâ€™inclusion dâ€™image sur une page web forgÃ©e par lâ€™attaquant et ensuite de faire visiter cette page par la victime. Les requÃªtes vers les images partant avec les cookies de lâ€™utilisateur, il est alors possible de forger des requÃªtes GET.</p>

<p><img src="/assets/img/csrf_02.png" alt="" /></p>

<p>Pour plus dâ€™informations, je vous invite Ã  lire lâ€™article du site de lâ€™ANSSI qui prÃ©sente plus en dÃ©tail ce type dâ€™attaque :</p>

<p><a href="https://www.cert.ssi.gouv.fr/information/CERTA-2008-INF-003/">Les attaques de type Â« cross-site request forgery</a></p>

<h2 id="exploitation-du-ping">Exploitation du ping</h2>

<p>Bien que nous envoyons via le ping une requÃ¨te POST, nous avons cependant une contrainte qui limite sÃ©rieusement son exploitation:</p>

<ul>
  <li>nous ne controlons pas le body de la requÃªte.</li>
</ul>

<p>En effet pour une requÃªte POST il serait pourtant intÃ©ressant de gÃ©rer le corps de notre requÃ¨te, afin de passer les paramÃ¨tres que nous souhaitons.</p>

<p>Cependant, celle-ci reste parfaitement exploitable sur diffÃ©rentes cibles.</p>

<h3 id="api">API</h3>

<p>Dans un monde oÃ¹ la plus part des applications se transforment en API web il nâ€™est pas rare de voir des scÃ©narios oÃ¹ nous avons un endpoint <code class="language-plaintext highlighter-rouge">/user/&lt;user_id&gt;/&lt;action&gt;</code> et que celui-ci ne prend pas de paramÃ¨tre car il sâ€™agit en vÃ©ritÃ© dâ€™un toggle.</p>

<p>Ce type de cas est exploitable, car le corps ne sera alors pas parsÃ© et les paramÃ¨tres seront pris directement dans lâ€™url.</p>

<p>Prenons la micro API flask ci-dessous, celle-ci est parfaitement vulnÃ©rable, car bien que nous envoyons un corps inutile, celui-ci ne sera jamais utilisÃ©, mais lâ€™action sera tout de mÃªme effectuÃ©.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/user/&lt;name&gt;/&lt;action&gt;'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">'POST'</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">hello_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">name</span>
    <span class="k">return</span> <span class="s">"Hello {}! We will do {} !"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="mauvais-code-php">Mauvais code PHP</h3>

<p>Si nous avons besoin de passer des paramÃ¨tres aux endpoints, nous sommes certes bloquÃ©s. Enfin presque ! Cela serait sans compter sur les meilleurs amis du pentest, les dÃ©veloppeurs !</p>

<p>En effet, dans certains cas il est possible de passer les paramÃ¨tres de notre requÃªte POST dans lâ€™url et ceux-ci seront tout de mÃªme utilisÃ©s dans le traitement.</p>

<p>Par exemple en PHP, il est parfois possible de croiser lâ€™utilisation de <code class="language-plaintext highlighter-rouge">$_REQUEST</code> en lieu et place de <code class="language-plaintext highlighter-rouge">$_GET</code> ou <code class="language-plaintext highlighter-rouge">$_POST</code>, ce qui a pour effet que lors dâ€™une requÃªte, le paramÃ¨tre sera dâ€™abord rÃ©cupÃ©rÃ© dans le <code class="language-plaintext highlighter-rouge">$_GET</code> puis le <code class="language-plaintext highlighter-rouge">$_POST</code> et enfin dans les cookies.</p>

<p>Prenons par exemple le code php suivant :</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="nb">session_start</span><span class="p">();</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">'user'</span><span class="p">])){</span>
	<span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">'user'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'ImFlo'</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span><span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">'REQUEST_METHOD'</span><span class="p">]</span> <span class="o">===</span> <span class="s1">'POST'</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_REQUEST</span><span class="p">[</span><span class="s1">'usr'</span><span class="p">]))</span> <span class="p">{</span>
		<span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">'user'</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$_REQUEST</span><span class="p">[</span><span class="s1">'usr'</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">echo</span> <span class="s2">"&lt;h1&gt;</span><span class="si">{</span><span class="nv">$_SESSION</span><span class="p">[</span><span class="s2">"user"</span><span class="p">]</span><span class="si">}</span><span class="s2">&lt;/h1&gt;"</span><span class="p">;</span>
</code></pre></div></div>

<p>Il nous est parfaitement possible de lâ€™attaquer avec le ping suivant :</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#"</span> <span class="na">ping=</span><span class="s">"https://victim.local/foo.php?usr=patate"</span><span class="nt">&gt;</span>click me<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div>

<p>Le paramÃ¨tre <code class="language-plaintext highlighter-rouge">usr</code> se trouvant dans lâ€™url et celui-ci Ã©tant rÃ©cupÃ©rÃ© via <code class="language-plaintext highlighter-rouge">$_REQUEST</code>, il sera alors utilisÃ© lorsque la requÃªte POST sera reÃ§u par le site victime.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bien que la surface dâ€™attaque de cet attribut soit moindre, du fait quâ€™il requiert plusieurs conditions prÃ©alables pour Ãªtre utile Ã  une attaque CSRF. Il reste nÃ©anmoins intÃ©ressant de contrÃ´ler si celui-ci nâ€™est pas exploitable, surtout si aucun token anti-csrf nâ€™est prÃ©sent.</p>

<p>Pour contrÃ´ler son exploitation, il est juste necessaire de controler via Burp ou autre si:</p>
<ul>
  <li>les paramÃ¨tres de la requÃ¨te sont utiles et utilisÃ©s, en les retirant</li>
  <li>essayer de les passer dans le query string afin de voir si ce contournement est possible</li>
</ul>

<p>Si une de ces conditions est vrai alors vous aurez une CSRF via cette technique.</p>
:ET